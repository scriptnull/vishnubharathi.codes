<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vishnu Bharathi</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vishnubharathi.codes/"/>
  <updated>2024-07-27T01:28:05.151Z</updated>
  <id>https://vishnubharathi.codes/</id>
  
  <author>
    <name>Vishnu Bharathi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Know when to break up with Go&#39;s http.DefaultClient</title>
    <link href="https://vishnubharathi.codes/blog/know-when-to-break-up-with-go-http-defaultclient/"/>
    <id>https://vishnubharathi.codes/blog/know-when-to-break-up-with-go-http-defaultclient/</id>
    <published>2024-07-07T15:32:27.000Z</published>
    <updated>2024-07-27T01:28:05.151Z</updated>
    
    <content type="html"><![CDATA[<p>These might be the first set of snippets that you see when trying to use Go‚Äôs HTTP client. (taken from the ‚Äúoverview‚Äù section of <a href="https://pkg.go.dev/net/http">the standard library docs</a>)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">&quot;http://example.com/&quot;</span>)</span><br><span class="line">...</span><br><span class="line">resp, err := http.Post(<span class="string">&quot;http://example.com/upload&quot;</span>, <span class="string">&quot;image/jpeg&quot;</span>, &amp;buf)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>The same set of snippets has the potential to cause your first production outage. It is perfectly good code (up to a certain point). Things will start to get dirty when you introduce the following things into the mix:</p><ul><li>when your program is starting to make a lot of HTTP calls.</li><li>when your program is making HTTP calls to more than one service (host names).</li></ul><p>The reason behind it is this little variable declared in the <code>net/http</code> package.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultClient = &amp;Client&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Meet-the-DefaultClient"><a href="#Meet-the-DefaultClient" class="headerlink" title="Meet the DefaultClient"></a>Meet the DefaultClient</h2><p><code>DefaultClient</code> is of type <code>*http.Client</code> and <code>http.Client</code> is the struct that has all the code to perform HTTP calls. <code>DefaultClient</code> is a HTTP client with all the underlying settings pointing to the default values.</p><p>When you try calling those package-level HTTP methods like <code>http.Get</code>, <code>http.Post</code>, <code>http.Do</code> etc., the HTTP call is made using the <code>DefaultClient</code> variable. Two fields in the <code>http.Client</code> struct could translate the ‚Äúdefault‚Äù and ‚Äúshared‚Äù behavior of <code>http.DefaultClient</code> into potential problems:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Transport specifies the mechanism by which individual</span></span><br><span class="line"><span class="comment">// HTTP requests are made.</span></span><br><span class="line"><span class="comment">// If nil, DefaultTransport is used.</span></span><br><span class="line">Transport RoundTripper</span><br><span class="line"></span><br><span class="line"><span class="comment">// .............</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Timeout specifies a time limit for requests made by this</span></span><br><span class="line"><span class="comment">// Client. The timeout includes connection time, any</span></span><br><span class="line"><span class="comment">// redirects, and reading the response body. The timer remains</span></span><br><span class="line"><span class="comment">// running after Get, Head, Post, or Do return and will</span></span><br><span class="line"><span class="comment">// interrupt reading of the Response.Body.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Timeout of zero means no timeout.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The Client cancels requests to the underlying Transport</span></span><br><span class="line"><span class="comment">// as if the Request&#x27;s Context ended.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">Timeout time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The default value for <code>Timeout</code> is zero, so the <code>http.DefaultClient</code> does not timeout by default and will try to hold on to a local port/socket as long as the connection is live. What if there are too many requests? Combine this with an HTTP server which doesn‚Äôt timeout. Bingo! You got a production outage. You will run out of ports and there won‚Äôt be newer ports available for making further HTTP calls.</p><p>Next up is the <code>Transport</code> field in the <code>http.Client</code>. By default, the following <code>DefaultTransport</code> would be used in <code>DefaultClient</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">Proxy: ProxyFromEnvironment,</span><br><span class="line">DialContext: defaultTransportDialContext(&amp;net.Dialer&#123;</span><br><span class="line">Timeout:   <span class="number">30</span> * time.Second,</span><br><span class="line">KeepAlive: <span class="number">30</span> * time.Second,</span><br><span class="line">&#125;),</span><br><span class="line">ForceAttemptHTTP2:     <span class="literal">true</span>,</span><br><span class="line">MaxIdleConns:          <span class="number">100</span>,</span><br><span class="line">IdleConnTimeout:       <span class="number">90</span> * time.Second,</span><br><span class="line">TLSHandshakeTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">ExpectContinueTimeout: <span class="number">1</span> * time.Second,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(a lot of things in there, but turn your attention to <code>MaxIdleConns</code>)</p><p>Here is the doc on what it does:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MaxIdleConns controls the maximum number of idle (keep-alive)</span></span><br><span class="line"><span class="comment">// connections across all hosts. Zero means no limit.</span></span><br><span class="line">MaxIdleConns <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>Since the <code>DefaultClient</code> is shared, you might end up making calls to more than one service (host names) from it. In that case, there might be an unfair distribution of the <code>MaxIdleConns</code> maintained by the default client for the given set of hosts.</p><h2 id="A-small-example"><a href="#A-small-example" class="headerlink" title="A small example"></a>A small example</h2><p>Let us take an example here:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LoanAPIClient <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LoanAPIClient)</span> <span class="title">List</span><span class="params">()</span> <span class="params">([]Loan, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">err := http.Get(<span class="string">&quot;https://loan.api.example.com/v1/loans&quot;</span>)</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PaymentAPIClient <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PaymentAPIClient)</span> <span class="title">Pay</span><span class="params">(amount <span class="keyword">int</span>)</span> <span class="params">(error)</span></span> &#123;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">err := http.Post(<span class="string">&quot;https://payment.api.example.com/v1/card&quot;</span>, <span class="string">&quot;application/json&quot;</span>, &amp;req)</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Both <code>LoanAPIClient</code> and <code>PaymentAPIClient</code> use the <code>http.DefaultClient</code> by calling into <code>http.Get</code> and <code>http.Post</code>. Let us say our program makes 80 calls from <code>LoanAPIClient</code> initially and then makes 200 calls from <code>PaymentAPIClient</code>. By default <code>DefaultClient</code> only maintains 100 maximum idle connections. So, <code>LoadAPIClient</code> will capture 80 spots in those 100 spots, and <code>PaymentAPIClient</code> will only get 20 remanining spots. This means that for the rest of 60 calls from <code>PaymentAPIClient</code>, a new connection needs to be opened and closed. This will cause unnecessary pressure on the payments API server. The allocation of these MaxIdleConns will soon get out of your hands! (trust me üòÖ)</p><h2 id="How-do-we-fix-this"><a href="#How-do-we-fix-this" class="headerlink" title="How do we fix this?"></a>How do we fix this?</h2><p>Increase the <code>MaxIdleConns</code>? Yes, you can but if the client is still shared between <code>LoanAPIClient</code> and <code>PaymentAPIClient</code> then that too shall get out of hand at some scale.</p><p>I discovered the sibling of <code>MaxIdleConns</code> and that is <code>MaxIdleConnsPerHost</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MaxIdleConnsPerHost, if non-zero, controls the maximum idle</span></span><br><span class="line"><span class="comment">// (keep-alive) connections to keep per-host. If zero,</span></span><br><span class="line"><span class="comment">// DefaultMaxIdleConnsPerHost is used.</span></span><br><span class="line">MaxIdleConnsPerHost <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>This could help in maintaining a predictable number of idle connections for each endpoint (host name).</p><h2 id="OK-how-do-I-really-fix-this"><a href="#OK-how-do-I-really-fix-this" class="headerlink" title="OK, how do I really fix this?"></a>OK, how do I really fix this?</h2><p>If your program is calling into more than one HTTP service, then you might most probably want to tweak other settings of the Client too. So, it might be beneficial to have a separate <code>http.Client</code> for these services. That way we can fine-tune them if needed in the future.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LoanAPIClient <span class="keyword">struct</span> &#123;</span><br><span class="line">client *http.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PaymentAPIClient <span class="keyword">struct</span> &#123;</span><br><span class="line">client *http.Client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="It-is-fine"><a href="#It-is-fine" class="headerlink" title="It is fine"></a>It is fine</h2><p>The conclusion would be this: It is okay to use <code>http.DefaultClient</code> to start with. But if you think you will have more clients and will make more API calls, avoid it.</p><p>Bonus: If you are authoring a library that has an API client, do a favor for your users: provide a way to customize the <code>http.Client</code> that you are using to make API calls. That way, your users have full control of what they would like to achieve while using your client.</p><p>~ ~ ~ ~</p><p>HTTP Clients inside an HTTP Server talking to another HTTP Server that has HTTP Clients, all authored by you. That will be your cue.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;These might be the first set of snippets that you see when trying to use Go‚Äôs HTTP client. (taken from the ‚Äúoverview‚Äù section of &lt;a href=
      
    
    </summary>
    
    
      <category term="go" scheme="https://vishnubharathi.codes/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Against the io.TeeReader</title>
    <link href="https://vishnubharathi.codes/blog/against-the-io.teereader/"/>
    <id>https://vishnubharathi.codes/blog/against-the-io.teereader/</id>
    <published>2024-06-28T18:37:19.000Z</published>
    <updated>2024-07-27T01:28:05.147Z</updated>
    
    <content type="html"><![CDATA[<p>This is a follow-up blog post to my previous blog post about the <code>io.TeeReader</code> in Go. Here is the link for it if you haven‚Äôt read it yet: <a href="https://vishnubharathi.codes/blog/a-silly-mistake-that-i-made-with-io.teereader/">https://vishnubharathi.codes/blog/a-silly-mistake-that-i-made-with-io.teereader/</a></p><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>The motivation for this blog post is <a href="https://www.reddit.com/r/golang/comments/1dpfz28/comment/lah1uzz/">this Reddit comment</a>. One of the reasons why I write blog posts and share them on the internet is because I almost always learn more from the comments. That comment made me think more about the code I wrote in the previous blog post and realize some things I want to write up here. (A big thanks to the people writing insightful comments on the internet)</p><h2 id="That-weird-new-bytes-Buffer"><a href="#That-weird-new-bytes-Buffer" class="headerlink" title="That weird new(bytes.Buffer)"></a>That weird <code>new(bytes.Buffer)</code></h2><p>To recap, I had a <code>io.Reader</code> as input and I was trying to read it twice so that I could upload the same data two times. Here is how the final solution looked like when using an <code>io.TeeReader</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">contentForSecondUpload := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">contentForFirstUpload := io.TeeReader(r, contentForSecondUpload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := firstUpload(contentForFirstUpload); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := secondUpload(contentForSecondUpload); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I always felt weird about the <code>new(bytes.Buffer)</code> that I have allocated in the code.</p><h2 id="The-whole-point"><a href="#The-whole-point" class="headerlink" title="The whole point"></a>The whole point</h2><p>The whole point of <code>io.TeeReader</code> is to take in one source reader and perform reads on it efficiently and make the data available at the other two ends of the ‚ÄúT‚Äù.</p><p>One of the highlights of that Reddit comment is, if I am allocating a buffer to store the contents of the source reader, why use a TeeReader at all?</p><blockquote><p>If you‚Äôre going to allocate a buffer, then you might read the entire thing into memory first and read it twice.</p></blockquote><p>That would look like</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">contentForUpload, err := io.ReadAll(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := firstUpload(bytes.NewReader(contentForUpload)); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := secondUpload(bytes.NewReader(contentForUpload)); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This is a valid solution if I am okay with reading the entire input in memory and want my uploads to happen synchronously one after another.</p><h2 id="io-TeeReader-io-Pipe"><a href="#io-TeeReader-io-Pipe" class="headerlink" title="io.TeeReader + io.Pipe"></a>io.TeeReader + io.Pipe</h2><p>The comment made me realize that we could use <code>io.TeeReader</code> and <code>io.Pipe</code> together to achieve concurrent uploads like my final solution in the previous blog post did.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">contentForSecondUpload, contentWriter := io.Pipe()</span><br><span class="line">contentForFirstUpload := io.TeeReader(r, contentWriter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> upload errgroup.Group</span><br><span class="line">upload.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> firstUpload(contentForFirstUpload)</span><br><span class="line">&#125;)</span><br><span class="line">upload.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> secondUpload(contentForSecondUpload)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> upload.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I am going to take this step by step. The above program would cause a deadlock. The reason: <code>contentWriter</code> is not closed and the <code>secondUpload</code> will always be waiting for more content to be available which it will never receive. To fix it, we must close the <code>contentWriter</code> somewhere, but where?</p><p>In the case of the pure <code>io.Pipe</code> implementation in the previous blog post, it was clear: We close the writers in the go routine where we finish the writing.</p><p>In the case of a TeeReader, the writes for <code>contentForSecondUpload</code> is complete when the read of <code>contentForFirstUpload</code> is finished. That looks like:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">contentForSecondUpload, contentWriter := io.Pipe()</span><br><span class="line">contentForFirstUpload := io.TeeReader(r, contentWriter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> upload errgroup.Group</span><br><span class="line">upload.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">contentWriter.CloseWithError(err)</span><br><span class="line">&#125;()</span><br><span class="line">err = firstUpload(contentForFirstUpload)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;)</span><br><span class="line">upload.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> secondUpload(contentForSecondUpload)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> upload.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I feel that the above code would be hard to follow. It can easily make one spend time thinking about ‚Äúwhy would they close the writer of the second reader after reading the first reader?‚Äù.</p><p>The pure <code>io.Pipe</code> implementation feels more natural and human-friendly: we close the writer in the go routine where we are done writing to all the writers. At the same time, it gets the job done.</p><h2 id="Verdict"><a href="#Verdict" class="headerlink" title="Verdict"></a>Verdict</h2><p>I will avoid using <code>io.TeeReader</code> at all places and prefer using <code>io.Pipe + io.MultiWriter</code> instead. (the code from the previous blog post)</p><p>That makes the code efficient, concurrent, and easy to read/write/extend.</p><p>~ ~ ~ ~</p><p>Always use the pipe and close it.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This is a follow-up blog post to my previous blog post about the &lt;code&gt;io.TeeReader&lt;/code&gt; in Go. Here is the link for it if you haven‚Äôt 
      
    
    </summary>
    
    
      <category term="go" scheme="https://vishnubharathi.codes/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>A silly mistake that I made with io.TeeReader</title>
    <link href="https://vishnubharathi.codes/blog/a-silly-mistake-that-i-made-with-io.teereader/"/>
    <id>https://vishnubharathi.codes/blog/a-silly-mistake-that-i-made-with-io.teereader/</id>
    <published>2024-06-27T00:39:47.000Z</published>
    <updated>2024-07-27T01:28:05.147Z</updated>
    
    <content type="html"><![CDATA[<p>I recently made a silly mistake while using <code>io.TeeReader</code> in Go and I am writing this blog post to sum up my learnings from this experience.</p><h2 id="Why-I-used-it-in-the-first-place"><a href="#Why-I-used-it-in-the-first-place" class="headerlink" title="Why I used it in the first place"></a>Why I used it in the first place</h2><p>Ok, here is why I chose to use it in the first place: I had some content and two functions that needed that content and perform uploads to two different HTTP endpoints. Something like</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Upload(strings.NewReader(<span class="string">&quot;hello world&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := firstUpload(r); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := secondUpload(r); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstUpload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">content := io.MultiReader(strings.NewReader(<span class="string">&quot;first upload:&quot;</span>), r, strings.NewReader(<span class="string">&quot;\n&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> _, err := io.Copy(os.Stdout, content); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">secondUpload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">content := io.MultiReader(strings.NewReader(<span class="string">&quot;second upload:&quot;</span>), r, strings.NewReader(<span class="string">&quot;\n&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> _, err := io.Copy(os.Stdout, content); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The output of the above program would be</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first upload:hello world</span><br><span class="line">second upload:</span><br></pre></td></tr></table></figure><p>The first upload consumes all the data from the reader and by the time the reader reaches the second upload, there isn‚Äôt anything to be read. If this is new to you, I encourage you to take a look at the standard lib docs for <code>io.Reader</code> to better understand the situation: <a href="https://pkg.go.dev/io#Reader">https://pkg.go.dev/io#Reader</a></p><h2 id="Using-TeeReader-but-with-my-mistake"><a href="#Using-TeeReader-but-with-my-mistake" class="headerlink" title="Using TeeReader (but with my mistake)"></a>Using TeeReader (but with my mistake)</h2><p>OK, so what do I do now? I google search the problem and discover about Go‚Äôs <a href="https://pkg.go.dev/io#TeeReader">io.TeeReader</a>. Let us see what the program would look like after I tried to use the TeeReader.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">contentForFirstUpload := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">contentForSecondUpload := io.TeeReader(r, contentForFirstUpload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := firstUpload(contentForFirstUpload); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := secondUpload(contentForSecondUpload); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And the output for this is</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first upload:</span><br><span class="line">second upload:hello world</span><br></pre></td></tr></table></figure><p>That is weird. The second upload is succeeding but not the first one?</p><h2 id="Fixing-the-mistake"><a href="#Fixing-the-mistake" class="headerlink" title="Fixing the mistake"></a>Fixing the mistake</h2><p>This probably is the best place to quote the docs of <code>io.TeeReader</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TeeReader</span><span class="params">(r Reader, w Writer)</span> <span class="title">Reader</span></span></span><br></pre></td></tr></table></figure><blockquote><p>TeeReader returns a Reader that writes to w what it reads from r. All reads from r performed through it are matched with corresponding writes to w. There is no internal buffering - the write must complete before the read completes. Any error encountered while writing is reported as a read error.</p></blockquote><p>So we get back a Reader (<code>contentForSecondUpload</code> in our case) and when that is read, a simultaneous write is happening to the writer (<code>contentForFirstUpload</code> in our case) that we pass. But what happens in the code is, we try to read from the writer before writes are happening to it.</p><p>I am not sure if I did a good job of explaining the fix in plain words above, but here is the code that fixes the problem:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">contentForSecondUpload := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">contentForFirstUpload := io.TeeReader(r, contentForSecondUpload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := firstUpload(contentForFirstUpload); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := secondUpload(contentForSecondUpload); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So rule no.1 here is: always read the reader returned back from <code>io.TeeReader</code> first. That is the thing that is copying the data and making it available for the other buffer (writer).</p><p>That‚Äôs it, that is the only rule.</p><h2 id="io-Pipe"><a href="#io-Pipe" class="headerlink" title="io.Pipe"></a>io.Pipe</h2><p>Now that we have fixed the problem, I think we can take a short detour to visit one of my favorite Go constructs: <code>io.Pipe</code> which could also help solve these kinds of problems.</p><p>Here is a quick refactor of our code using <code>io.Pipe</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> upload errgroup.Group</span><br><span class="line"></span><br><span class="line">fr, fw := io.Pipe()</span><br><span class="line">upload.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> firstUpload(fr)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">sr, sw := io.Pipe()</span><br><span class="line">upload.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> secondUpload(sr)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">upload.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fw.CloseWithError(err)</span><br><span class="line">sw.CloseWithError(err)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">_, err = io.Copy(io.MultiWriter(fw, sw), r)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> upload.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This has some advantages and one of them would have helped me in avoiding my mistake with <code>io.TeeReader</code>.</p><ul><li>uploads become concurrent naturally unlike TeeReader where it is sequential.</li><li>the order in which we read the readers for the first upload and second upload does not matter anymore.</li></ul><p>With that said, I would still be mindful about introducing <code>io.Pipe</code>. Here is what I have decided.</p><p>If I need to write to one or two writers and do not need concurrency, I would stick with <code>io.TeeReader</code>. I will stick to <code>io.Pipe</code> for every other case.</p><p>I have changed my mind a bit, please turn to the next page: <a href="https://vishnubharathi.codes/blog/against-the-io.teereader/">https://vishnubharathi.codes/blog/against-the-io.teereader/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I recently made a silly mistake while using &lt;code&gt;io.TeeReader&lt;/code&gt; in Go and I am writing this blog post to sum up my learnings from t
      
    
    </summary>
    
    
      <category term="go" scheme="https://vishnubharathi.codes/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Exploring Middlewares in Go</title>
    <link href="https://vishnubharathi.codes/blog/exploring-middlewares-in-go/"/>
    <id>https://vishnubharathi.codes/blog/exploring-middlewares-in-go/</id>
    <published>2024-05-20T18:40:08.000Z</published>
    <updated>2024-07-27T01:28:05.151Z</updated>
    
    <content type="html"><![CDATA[<p>I came across ‚ÄúMiddlewares‚Äù for writing HTTP servers originally in the Node.js ecosystem. There is this beautiful library called <a href="https://expressjs.com/">express</a> which sparked the joy of middleware in me. In case you haven‚Äôt heard of middleware before, I think you should read <a href="https://expressjs.com/en/guide/using-middleware.html">this beautiful page</a> from expressjs documentation to get a taste of them. (I genuinely feel that it is the best possible introduction for middleware, hence opening up the post with it)</p><p>With enough JavaScript for the day, we will jump into Go now. üòÖ</p><p>My goal for this post is to understand how to {use, write} middlewares in Go HTTP servers. We will also try to search the internet and surface some Go middlewares that we can add to our day-to-day toolkit.</p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Let us take a simple problem and work our way upwards. Here is the problem statement:</p><p>Write an HTTP server that contains multiple routes. When a request is made to a route, print a log line at the start and the end of the request. Something like</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2024&#x2F;05&#x2F;21 00:49:32 INFO start method&#x3D;GET path&#x3D;&#x2F;one</span><br><span class="line">2024&#x2F;05&#x2F;21 00:49:32 INFO end method&#x3D;GET path&#x3D;&#x2F;one</span><br><span class="line">2024&#x2F;05&#x2F;21 00:49:34 INFO start method&#x3D;GET path&#x3D;&#x2F;two</span><br><span class="line">2024&#x2F;05&#x2F;21 00:49:34 INFO end method&#x3D;GET path&#x3D;&#x2F;two</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Without-Middleware"><a href="#Without-Middleware" class="headerlink" title="Without Middleware"></a>Without Middleware</h3><p>A solution without using middleware would look like</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log/slog&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/one&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">slog.Info(<span class="string">&quot;start&quot;</span>, <span class="string">&quot;method&quot;</span>, r.Method, <span class="string">&quot;path&quot;</span>, r.URL.Path)</span><br><span class="line"><span class="keyword">defer</span> slog.Info(<span class="string">&quot;end&quot;</span>, <span class="string">&quot;method&quot;</span>, r.Method, <span class="string">&quot;path&quot;</span>, r.URL.Path)</span><br><span class="line"></span><br><span class="line">fmt.Fprintln(w, <span class="string">&quot;this is one&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/two&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">slog.Info(<span class="string">&quot;start&quot;</span>, <span class="string">&quot;method&quot;</span>, r.Method, <span class="string">&quot;path&quot;</span>, r.URL.Path)</span><br><span class="line"><span class="keyword">defer</span> slog.Info(<span class="string">&quot;end&quot;</span>, <span class="string">&quot;method&quot;</span>, r.Method, <span class="string">&quot;path&quot;</span>, r.URL.Path)</span><br><span class="line"></span><br><span class="line">fmt.Fprintln(w, <span class="string">&quot;this is two&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:3000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>How do we avoid copy-pasting those two lines to every HTTP handler function? Middlewares for the win!</p><h3 id="Basic-Middleware"><a href="#Basic-Middleware" class="headerlink" title="Basic Middleware"></a>Basic Middleware</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log/slog&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logRequest</span><span class="params">(next <span class="keyword">func</span>(http.ResponseWriter, *http.Request)</span>) <span class="title">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">slog.Info(<span class="string">&quot;start&quot;</span>, <span class="string">&quot;method&quot;</span>, r.Method, <span class="string">&quot;path&quot;</span>, r.URL.Path)</span><br><span class="line"><span class="keyword">defer</span> slog.Info(<span class="string">&quot;end&quot;</span>, <span class="string">&quot;method&quot;</span>, r.Method, <span class="string">&quot;path&quot;</span>, r.URL.Path)</span><br><span class="line"></span><br><span class="line">next(w, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">oneHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(w, <span class="string">&quot;this is one&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoHander</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(w, <span class="string">&quot;this is two&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/one&quot;</span>, logRequest(oneHandler))</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/two&quot;</span>, logRequest(twoHander))</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:3000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Using-http-HandleFunc"><a href="#Using-http-HandleFunc" class="headerlink" title="Using http.HandleFunc"></a>Using http.HandleFunc</h3><p>We are not done yet! There is still room for improvement. Notice how big the method signature for <code>logRequest</code> is! we can start from there. I remember a standard library type called <code>http.HandlerFunc</code> which could be used in the place of <code>func(ResponseWriter, *Request)</code>. If we start using it, our middleware looks like this.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logRequest</span><span class="params">(next http.HandlerFunc)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">slog.Info(<span class="string">&quot;start&quot;</span>, <span class="string">&quot;method&quot;</span>, r.Method, <span class="string">&quot;path&quot;</span>, r.URL.Path)</span><br><span class="line"><span class="keyword">defer</span> slog.Info(<span class="string">&quot;end&quot;</span>, <span class="string">&quot;method&quot;</span>, r.Method, <span class="string">&quot;path&quot;</span>, r.URL.Path)</span><br><span class="line"></span><br><span class="line">next(w, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>While browsing through the Go docs, I noticed that <code>http.HandleFunc</code> has the below method signature.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span></span><br></pre></td></tr></table></figure><p>That raised a question in me. Why don‚Äôt they use <code>func HandleFunc(pattern string, handler http.HandlerFunc)</code> instead? I thought <code>http.HandlerFunc</code> is an alias type for <code>func(ResponseWriter, *Request)</code>. Digging through the standard library source code had the answer. It seems like it is just not a simple alias, but more than that. Copy pasting the implementation of <code>http.HanderFunc</code> for you straight out of Go source :D</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The HandlerFunc type is an adapter to allow the use of</span></span><br><span class="line"><span class="comment">// ordinary functions as HTTP handlers. If f is a function</span></span><br><span class="line"><span class="comment">// with the appropriate signature, HandlerFunc(f) is a</span></span><br><span class="line"><span class="comment">// [Handler] that calls f.</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>oh wow, so <code>http.HandlerFunc</code> is a <code>func(ResponseWriter, *Request)</code> which implements the <a href="https://pkg.go.dev/net/http#Handler">http.Handler</a> interface.</p><h3 id="Enter-http-Handler"><a href="#Enter-http-Handler" class="headerlink" title="Enter http.Handler"></a>Enter http.Handler</h3><p>Why would we need an adapter like <code>http.HandlerFunc</code> that implements the <code>http.Handler</code> interface. To understand, let us take a look at the interface definition.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>and also read through the <a href="https://pkg.go.dev/net/http#Handler">http.Handler documentation</a>. At first, it didn‚Äôt solve my doubt, but then I discovered <a href="https://pkg.go.dev/net/http#example-Handle">this beautiful example</a> in the docs. Copy pasting the example from the docs here for you to have a quick look.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> countHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.Mutex <span class="comment">// guards n</span></span><br><span class="line">n  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *countHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">h.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> h.mu.Unlock()</span><br><span class="line">h.n++</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;count is %d\n&quot;</span>, h.n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.Handle(<span class="string">&quot;/count&quot;</span>, <span class="built_in">new</span>(countHandler))</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wow, did you get it? Sometimes your handler is more than just a <code>func(http.ResponseWriter, *http.Request)</code>. It could be a struct that contains data that could be used in your request logic. Like in the above case, <code>countHandler</code> maintains a counter protected by a mutex. Each and every request to <code>/count</code> would increment the counter atomically.</p><p>For simple routes, which are just a bunch of instructions we could use <code>http.HandleFunc</code>. But once your handler gets complex, like having to maintain data that is common to all requests of the handler, then move upward and go for <code>http.Handle</code>.</p><p>woah, this just cleared my long-standing doubt about ‚Äúwhen to use <code>http.Handle</code> and <code>http.HandleFunc</code>?‚Äù</p><p>It is getting a bit clearer now on why the <code>http.Handler</code> interface is needed. With two ways of defining a HTTP handler: one being to write a <code>func(http.ResponseWriter, *http.Request)</code> and pass it to <code>http.HandleFunc</code> and another being to write a struct with the necessary logic and pass it down to <code>http.Handle</code> function, the standard libary needs a common ground in which all its methods can operate on both the types of handlers. Hence an interface.</p><h3 id="http-HandlerFunc-to-http-Handler"><a href="#http-HandlerFunc-to-http-Handler" class="headerlink" title="http.HandlerFunc to http.Handler"></a>http.HandlerFunc to http.Handler</h3><p>Now that it is evident that a Go programmer could choose between using <code>http.Handle</code> or <code>http.HandleFunc</code> to serve their handlers, it is necessary that any HTTP middleware should work for both of those use cases. With the current approach to our solution, we will only support middlewares that are input to <code>http.HandleFunc</code>. Hence moving our middleware to use <code>http.Handler</code> interface, that way we could accommodate both types of handlers.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log/slog&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logRequest</span><span class="params">(next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">slog.Info(<span class="string">&quot;start&quot;</span>, <span class="string">&quot;method&quot;</span>, r.Method, <span class="string">&quot;path&quot;</span>, r.URL.Path)</span><br><span class="line"><span class="keyword">defer</span> slog.Info(<span class="string">&quot;end&quot;</span>, <span class="string">&quot;method&quot;</span>, r.Method, <span class="string">&quot;path&quot;</span>, r.URL.Path)</span><br><span class="line"></span><br><span class="line">next.ServeHTTP(w, r)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">oneHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(w, <span class="string">&quot;this is one&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoHander</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(w, <span class="string">&quot;this is two&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.Handle(<span class="string">&quot;/one&quot;</span>, logRequest(http.HandlerFunc(oneHandler)))</span><br><span class="line">http.Handle(<span class="string">&quot;/two&quot;</span>, logRequest(http.HandlerFunc(twoHander)))</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:3000&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Standard-library-Middlewares"><a href="#Standard-library-Middlewares" class="headerlink" title="Standard library Middlewares"></a>Standard library Middlewares</h2><p>The <code>net/http</code> package in the standard library of Go contains middlewares. If you haven‚Äôt realized it yet, don‚Äôt worry. That is because they don‚Äôt advertise those functions as ‚Äúmiddleware‚Äù (ctrl+f on docs for middleware leaves you with 0 matches :D)</p><h3 id="AllowQuerySemicolons"><a href="#AllowQuerySemicolons" class="headerlink" title="AllowQuerySemicolons"></a>AllowQuerySemicolons</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AllowQuerySemicolons</span><span class="params">(h Handler)</span> <span class="title">Handler</span></span></span><br></pre></td></tr></table></figure><p>TIL that we could use semicolons instead of ampersands in query strings (though this style is deprecated by W3C). Read more about it here: <a href="https://github.com/golang/go/issues/25192">https://github.com/golang/go/issues/25192</a>. This middleware is present in the stdlib for solving that problem by replacing the <code>;</code> with <code>&amp;</code> under the hood. </p><h3 id="MaxBytesHandler"><a href="#MaxBytesHandler" class="headerlink" title="MaxBytesHandler"></a>MaxBytesHandler</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MaxBytesHandler</span><span class="params">(h Handler, n <span class="keyword">int64</span>)</span> <span class="title">Handler</span></span></span><br></pre></td></tr></table></figure><p>This could be used to limit the acceptable request body size. Under the hood, it uses <code>MaxBytesReader</code>:</p><blockquote><p>MaxBytesReader prevents clients from accidentally or maliciously sending a large request and wasting server resources. If possible, it tells the ResponseWriter to close the connection after the limit has been reached.</p></blockquote><h3 id="StripPrefix"><a href="#StripPrefix" class="headerlink" title="StripPrefix"></a>StripPrefix</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StripPrefix</span><span class="params">(prefix <span class="keyword">string</span>, h Handler)</span> <span class="title">Handler</span></span></span><br></pre></td></tr></table></figure><p>The docs says</p><blockquote><p>StripPrefix returns a handler that serves HTTP requests by removing the given prefix from the request URL‚Äôs Path (and RawPath if set) and invoking the handler h.</p></blockquote><p>My first impression is how could this be useful. Oh, wait for the blast! Here we go once again with a beautiful copy-paste of an stdlib example.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// To serve a directory on disk (/tmp) under an alternate URL</span></span><br><span class="line"><span class="comment">// path (/tmpfiles/), use StripPrefix to modify the request</span></span><br><span class="line"><span class="comment">// URL&#x27;s path before the FileServer sees it:</span></span><br><span class="line">http.Handle(<span class="string">&quot;/tmpfiles/&quot;</span>, http.StripPrefix(<span class="string">&quot;/tmpfiles/&quot;</span>, http.FileServer(http.Dir(<span class="string">&quot;/tmp&quot;</span>))))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TimeoutHandler"><a href="#TimeoutHandler" class="headerlink" title="TimeoutHandler"></a>TimeoutHandler</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TimeoutHandler</span><span class="params">(h Handler, dt time.Duration, msg <span class="keyword">string</span>)</span> <span class="title">Handler</span></span></span><br></pre></td></tr></table></figure><p>As the name says, it times out the handler if the request is taking more than the given duration.</p><h2 id="Third-party-Middlewares"><a href="#Third-party-Middlewares" class="headerlink" title="Third-party Middlewares"></a>Third-party Middlewares</h2><p>I came across this beautiful library called <code>chi</code> which comes loaded up with a bunch of middlewares out of the box: <a href="https://github.com/go-chi/chi?tab=readme-ov-file#middlewares">https://github.com/go-chi/chi?tab=readme-ov-file#middlewares</a></p><p>I would suggest starting with the default chi recommendation:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A good base middleware stack</span></span><br><span class="line">r.Use(middleware.RequestID)</span><br><span class="line">r.Use(middleware.RealIP)</span><br><span class="line">r.Use(middleware.Logger)</span><br><span class="line">r.Use(middleware.Recoverer)</span><br></pre></td></tr></table></figure><p>and then build up the chain. Go explore and catch ‚Äòem all!</p><p>(also let me know your favorite middleware if you have one - because I am trying to discover more third-party middlewares in Go)</p><h2 id="Communicate"><a href="#Communicate" class="headerlink" title="Communicate"></a>Communicate</h2><p>When writing or using middleware, you may need to pass down a variable that was created by one middleware into another middleware or in the request handler. In the case of JS, we would just mutate the <code>request</code> object directly since it is dynamically typed :D (lol, good old days). In the case of Go, we can‚Äôt do that and we will need a way of passing through variables of any type via the available <code>ResponseWriter</code> or <code>Request</code> objects.</p><p>I have previously written a whole blog post on the <a href="https://vishnubharathi.codes/blog/context-with-value-pitfall">pitfalls of context.WithValue</a> and when not to use them. And well, this is actually the use-case where you can use them!</p><p>A context variable is available to you in all the middlewares and the handlers via the <code>http.Request</code> object. We could use that to store and pass down information. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> RequestKey <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">RequestIDKey RequestKey = <span class="string">&quot;request-id&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RequestID</span><span class="params">(next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">ctx := context.WithValue(r.Context(), RequestIDKey, uuid.New())</span><br><span class="line">next.ServeHTTP(w, r.WithContext(ctx))</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlerThatUsesRequestID</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">reqID, ok := r.Context().Value(RequestIDKey).(uuid.UUID)</span><br><span class="line"><span class="keyword">if</span> !ok || reqID == uuid.Nil &#123;</span><br><span class="line">fmt.Fprintln(w, <span class="string">&quot;this a request without requestID&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;request id is %s\n&quot;</span>, reqID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You still need to be careful while using <code>context.WithValue</code>. What if you miss calling a middleware, but try to look up the value that it is supposed to set in <code>r.Context</code>? It changes the trajectory of your request during runtime and in the worst case it will lead to runtime panics in your handler. I am wondering if we could somehow catch this kind of stuff during compile time (like maybe by writing a library or perhaps someone already thought about this before - if so, let me know!)</p><h2 id="Chain"><a href="#Chain" class="headerlink" title="Chain"></a>Chain</h2><p>You might soon end up having to call multiple middleware for your handlers. In that case, your code would look like:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// middlewares for unauthenticated routes</span></span><br><span class="line">http.Handle(<span class="string">&quot;/&quot;</span>, Logger(RequestID(homeHandler))))</span><br><span class="line"></span><br><span class="line"><span class="comment">// middlewares for authenticated routes</span></span><br><span class="line">http.Handle(<span class="string">&quot;/profile&quot;</span>, Logger(RequestID(BasicAuth(userProfileHandler)))))</span><br></pre></td></tr></table></figure><p>We need a way to chain the middleware and store the chain so that we can reuse it between handlers. I recently discovered a library for this, which might help here: <a href="https://github.com/justinas/alice">https://github.com/justinas/alice</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unAuth := alice.New(Logger, RequestID)</span><br><span class="line">auth := alice.New(Logger, RequestID, BasicAuth)</span><br><span class="line"></span><br><span class="line">http.Handle(<span class="string">&quot;/&quot;</span>, unAuth.Then(homeHandler))</span><br><span class="line">http.Handle(<span class="string">&quot;/profile&quot;</span>, auth.Then(userProfileHandler))</span><br></pre></td></tr></table></figure><p>You can also use a routing library like <code>chi</code> where the request middlewares are defined at the router level.</p><h2 id="Closing-Thoughts"><a href="#Closing-Thoughts" class="headerlink" title="Closing Thoughts"></a>Closing Thoughts</h2><p>I hope this exploration was useful to you! It definitely made me learn some unexpected things like ‚Äúwhen to use http.Handle? when to use http.HandleFunc? ‚Ä¶.‚Äù. This is also inspiring me to write a small middleware library that I have been thinking about.</p><p>~ ~ ~ ~</p><p>In an alternate universe, someone declared <code>type Middleware func(Handler) Handler</code> in <code>net/http</code> and (use your imagination).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I came across ‚ÄúMiddlewares‚Äù for writing HTTP servers originally in the Node.js ecosystem. There is this beautiful library called &lt;a href=
      
    
    </summary>
    
    
      <category term="go" scheme="https://vishnubharathi.codes/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Rough notes on GCP networking</title>
    <link href="https://vishnubharathi.codes/blog/rough-notes-on-google-cloud-networking/"/>
    <id>https://vishnubharathi.codes/blog/rough-notes-on-google-cloud-networking/</id>
    <published>2024-03-11T00:52:46.000Z</published>
    <updated>2024-07-27T01:28:05.155Z</updated>
    
    <content type="html"><![CDATA[<p>I am publishing my rough notes on Google Cloud networking which I collected while watching the first few episodes of the <a href="https://www.youtube.com/watch?v=0hN-dyOV10c&amp;list=PLDGXb-1k3XY1RaEfzp_nDSJMPP0iAQEtP">Google Cloud Networking playlist</a>. lol, I don‚Äôt know how many more times I will need to revise them.</p><p>(Any images seen here are attributed to the presentation in the video series mentioned above. This blog post is more like watching those videos on fast-forward and I would definitely encourage you to check out the videos if you would like more clarity)</p><h2 id="VPC"><a href="#VPC" class="headerlink" title="VPC"></a>VPC</h2><ul><li>VPC is a global construct<ul><li>You can create subnets that belong to a different region</li></ul></li><li>Shared VPC<ul><li>One host project has VPC and subnets</li><li>Share all or some subnets with other projects that host the project-level service</li></ul></li></ul><h2 id="Interconnecting-to-Google-Cloud"><a href="#Interconnecting-to-Google-Cloud" class="headerlink" title="Interconnecting to Google Cloud"></a>Interconnecting to Google Cloud</h2><ul><li>Layer 3<ul><li>Dedicated (Direct peering)</li><li>Shared (Carrier peering)</li><li>Needs VPN setup to tunnel into private address space</li><li>No SLAs</li><li>Free of cost (but check latest)</li></ul></li><li>Layer 2<ul><li>Dedicated Interconnect<ul><li>Costly (because Gcloud has dedicated hardware)</li><li>Dedicated bandwidth</li></ul></li><li>Partner Interconnect<ul><li>Example: Equinix fabric</li><li>Shared bandwidth other people who are using the interconnect</li></ul></li><li>Has SLA</li></ul></li></ul><h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><ul><li>Pre-programmed routes<ul><li>Automatically created.</li><li>User can‚Äôt delete or change these routes</li><li>Subnet routes are automatically created when a subnet is added to the network</li></ul></li><li>Default routes<ul><li>Pre-programmed 0.0.0.0/0 route to an internet gateway</li><li>Unlike pre-programmed routes, this can be changed.</li></ul></li><li>Cloud Router (CR)<ul><li>Cloud Router is similar to a traditional router but has differences that are important to understand</li><li>In a traditional router, a router provides two functionalities<ul><li>Control plane functionality - BGP route communication mechanisms.</li><li>Data plane functionality - packets go into the router and the router makes the decision of where to route it.</li></ul></li><li>Cloud router is a ‚Äúcontrol-plane‚Äù only device. Think about it as a BGP speaker. This only speaks BGP, but the routers that you have on-prem might speak other protocols.</li><li>What does Cloud Router do?<ul><li>Learns routes dynamically, configures routing tables, and pushes those routing tables to the VMs themselves.</li><li>So when a VM wants to send packets to another VM, it is a host-to-host communication rather than pushing the packet to a router and the router making a choice to reach the destination.</li></ul></li><li>It is a Google-managed process, controlled by you, that runs on a Google host. If it fails, Google Cloud will automatically try to restart it. However, the routing from host to host is not affected during this period since it is not a data plane device. BGP connectivity will be lost during this time, so you can‚Äôt add new routes. The best practice would be to run two cloud routers always.</li><li>Two routing modes<ul><li>(can be enabled when setting up your VPC)</li><li>Regional routing<ul><li>CR was brought up in a region. So it can only learn about the subnets in that particular region.</li><li>Be careful about using these because when a load balancer tries to reach something in us-west-1 but the request ends up in the CR present in us-east-1, then a black hole is created. (i.e. request is not able to be routed to us-west-1 because regional CR doesn‚Äôt even know that us-west-1 exists)</li></ul></li><li>Global routing<ul><li>Allows CR to pick up all the subnets in a VPC</li></ul></li></ul></li><li>Route Priority<ul><li>Route Priority is equivalent to the BGP MED metric (multi-exit discriminator)</li><li>Local routes have default MED (1000 if not changed)</li><li>Routes from other regions have a metric based on RTT added to the default MED value.</li><li>If you have multiple interconnects, you can use route priority to tell the preference order of where the request needs to go.</li></ul></li></ul></li><li>Advanced Route<ul><li>Static forwarding to a VPN gateway when cloud routers/dynamic routing isn‚Äôt used.</li><li>Force some IPs to be routed to a third-party service</li></ul></li></ul><h2 id="VPC-Peering"><a href="#VPC-Peering" class="headerlink" title="VPC Peering"></a>VPC Peering</h2><ul><li>In case of VPNs, you can adverstise only a few subnets between network. In case of VPC peering, it is binary. All subnets in VPC A will get advertised to all subnets in VPC B and vice versa. You are basically smashing two VPCs.</li><li>Security policies still exist in both the VPCs and there is no ‚Äúsingle‚Äù security policy for the smashed up VPC. So, if something is going wrong, check the firewall rules associated with both VPCs.</li><li>Can not have overlapping IP ranges</li><li>Non-transitive in nature</li><li>Quotas and Limits:<ul><li>15,500 total VMs across all peering relationships</li><li>A network can have upto 25 peered networks</li></ul></li></ul><h2 id="Load-Balancers"><a href="#Load-Balancers" class="headerlink" title="Load Balancers"></a>Load Balancers</h2><ul><li>Families (based on where they face)<ul><li>External load balancer: Internet-facing</li><li>Internal load balancer: Internal to google cloud</li></ul></li><li>Families (based on where they route to)<ul><li>Global</li><li>Regional</li></ul></li><li>Families (based on the level they operate at)<ul><li>Network Load balancers<ul><li>Layer 3 and 4.</li><li>These are external load balancers (internet-facing)</li><li>These are regional load balancers.</li><li>Highly available with multiple zones</li><li>Load balance TCP/UDP traffic and does not look at L7</li><li>Client IP is preserved, don‚Äôt need x-forwarded-for</li><li>It does not perform SSL termination, so your backend needs to do it</li><li>Client access can be controlled with the VPC Firewall</li><li>Balances traffic using 2, 3, or 5-tuple hashing<ul><li>2 tuple: {sourceIp, destIP}</li><li>3 tuple: {sourceIp, destIP, Protocol}</li><li>5 tuple: {sourceIp, destIP, sourcePort, destPort, Protocol}</li></ul></li><li>Session Affinity based on IP address</li><li>High performance = 1 million+ requests per second</li></ul></li><li>DNS-based Global LB<ul><li>This is how traditional public cloud usually had load balancing. But not how Google cloud load balancing works.</li><li><img src="https://github.com/scriptnull/vishnubharathi.codes/assets/4211715/145bb23d-d996-4292-bf20-26cbfc880b2b" alt="image"></li><li>IP address of servers in different region are added as DNS entries for the domain.</li><li>The DNS server gives back the IP address when requested in a load balancer fashion (like round robin)</li><li>Disadvantage: DNS caching happens at multiple places (web browsers, internet providers ec.), so it might be pointing to a invalid IP address at one of those layers</li></ul></li><li>Google Global Load Balancer (L7)<ul><li>Built for powering Google search, Gmail and other Google products and then adopted inside Google cloud</li><li><img src="https://github.com/scriptnull/vishnubharathi.codes/assets/4211715/0e178e1f-c9c9-472b-9506-f76385ae5870" alt="image"></li></ul></li><li>Single Global Anycast VIP (IPv4/IPv6) across region</li><li>Cross-region failure and fallback</li><li>Fast autoscaling</li><li>Highly available</li><li>Single point to apply global policies</li></ul></li><li>Internal Load Balancers<ul><li><img src="https://github.com/scriptnull/vishnubharathi.codes/assets/4211715/e918cf25-7f13-4697-8fb2-a8550125a5b0" alt="image"></li></ul></li><li>L4 Regional LB<ul><li>Internal (RFC 1918) VIP</li><li>Client IP Preserved</li><li>TCP, HTTP, HTTPS health checks</li><li>No middle proxy (delivered through SDN), High performance, and no chokepoints</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I am publishing my rough notes on Google Cloud networking which I collected while watching the first few episodes of the &lt;a href=&quot;https:/
      
    
    </summary>
    
    
      <category term="devops" scheme="https://vishnubharathi.codes/tags/devops/"/>
    
      <category term="cloud" scheme="https://vishnubharathi.codes/tags/cloud/"/>
    
  </entry>
  
</feed>
