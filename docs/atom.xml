<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vishnu Bharathi</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vishnubharathi.codes/"/>
  <updated>2024-12-12T18:27:53.836Z</updated>
  <id>https://vishnubharathi.codes/</id>
  
  <author>
    <name>Vishnu Bharathi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Too many clocks at my home</title>
    <link href="https://vishnubharathi.codes/blog/too-many-clocks-at-my-home/"/>
    <id>https://vishnubharathi.codes/blog/too-many-clocks-at-my-home/</id>
    <published>2024-12-12T18:17:26.000Z</published>
    <updated>2024-12-12T18:27:53.836Z</updated>
    
    <content type="html"><![CDATA[<p>This is supposed to be a distributed systems blog post that I <a href="https://bsky.app/profile/vishnubharathi.codes/post/3lcyrndlxvs2u">promised</a> to write, but I am unable to keep quiet about a fact that I realized while thinking about writing this post.</p><p>That is, ‚ÄúI got too many clocks at my home‚Äù - like one per room, except the bathrooms. Trying to convince my family to allow me to achieve full coverage, but they just won‚Äôt allow me to have a ticking clock in our bathrooms - lol üòÇ </p><h2 id="Clock-Skew"><a href="#Clock-Skew" class="headerlink" title="Clock Skew"></a>Clock Skew</h2><p>If you have a lot of clocks like me, then there is a good chance that not all the clocks in all rooms are showing the same time. The clock in my bedroom is five minutes faster than the clock in our hall. That makes me a time traveller when I go from one room to another room.</p><p>The time in my bedroom is 8:35 AM, but the time in my hall is 8:30 AM. If I believe in both of my clocks and walk from my bedroom to the hall, congrats to me because I have travelled back in time.</p><p>It seems like there is a similar situation at hand when you are running multiple different computers. Every machine has its own system clock. There is no guarantee that all the system clocks are having the same time. This difference in time has been causing headaches for programmers and this is what our computer scientists call it to be a ‚Äúclock skew‚Äù.</p><h2 id="NTP"><a href="#NTP" class="headerlink" title="NTP"></a>NTP</h2><p>What if I went through my house all day long and adjusted all the clocks to the same time? Will that make sure to get rid of the clock skew? Not really, the skew can still occur because the seconds hand in real-world clocks cannot be synchronized with one another. There are external factors like the battery power going down which could eventually cause a clock skew.</p><p>In the case of computing, there seems to be a protocol called  <a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">NTP (Network Time Protocol)</a> that helps do the equivalent of me going around the house and syncing clocks. It synchronizes the clocks between computers and helps us to maintain the clock skew to be minimum. I first heard about it back in 2016 or 2017 at work when we faced some problems due to the clocks going out of sync between the machines in our system. So we had to install the NTP daemon service on all the machines to solve the problem.</p><p>If you are using an NTP daemon in production, make sure to have an alerting and monitoring setup for it. I learned that some people go to the extremes of plotting graphs against the clock skew and network latency between the machines in their system [^1]. It might be good to have a sense of how much of a clock skew can usually happen while using NTP. 100 to 500 milliseconds seem to be a practical estimate for clock skews [^2].</p><h2 id="Reference-clocks"><a href="#Reference-clocks" class="headerlink" title="Reference clocks"></a>Reference clocks</h2><p>You might be wondering if two clocks are out of sync, which one does the NTP consider a source of truth and adjust accordingly.</p><p>To understand it, we have to visit where time comes from. Prepare to be amazed by <a href="https://en.wikipedia.org/wiki/Clock#History_of_time-measuring_devices">this list</a> of all kinds of ways humans have been finding time so far in history. If you scroll to the bottom of the list, you will find two kinds of clocks that are of interest to us here.</p><h3 id="Quartz-clock"><a href="#Quartz-clock" class="headerlink" title="Quartz clock"></a>Quartz clock</h3><blockquote><p>Quartz clocks are timepieces that use an <a href="https://en.wikipedia.org/wiki/Electronic_oscillator">electronic oscillator</a> regulated by a <a href="https://en.wikipedia.org/wiki/Quartz">quartz</a> crystal to keep time. [^3]</p></blockquote><p>If you ever wondered how your laptop shows the right time when you switch it off and turn it on after a month. The reason is that your laptop contains a quartz clock with a separate battery which runs always. When your operating system boots up, it gets the time from this clock.</p><h3 id="Atomic-clock"><a href="#Atomic-clock" class="headerlink" title="Atomic clock"></a>Atomic clock</h3><blockquote><p>An atomic clock is a <a href="https://en.wikipedia.org/wiki/Clock">clock</a> that measures time by monitoring the resonant frequency of atoms. [^4]</p></blockquote><p>Atomic clocks are the most accurate clocks in existence as of now. In fact, it is so accurate that we have to infer what a second is by using it ü§Ø </p><blockquote><p>The second, symbol s, is the SI unit of time. It is defined by taking the fixed numerical value of the caesium frequency, the unperturbed ground-state hyperfine transition frequency of the caesium-133 atom, to be 9192631770 when expressed in the unit Hz, which is equal to s‚àí1.</p></blockquote><p>While storing date-time values in your applications, you might have heard of Co-ordinated Universal Time (UTC).</p><blockquote><p>UTC is based on TAI, which is a weighted average of hundreds of <a href="https://en.wikipedia.org/wiki/Atomic_clock">atomic clocks</a> worldwide.</p></blockquote><p>Now you know how UTC is calculated! If you install NTP on your machines, it will use UTC as the reference time to adjust the clock skew on your machine.</p><p>Satellites (with atomic clocks installed on them) seem to be the ultimate reference clock. GPS receivers can get signals from these satellites about what time it is. NTP uses different levels of reference clocks and these levels are called startum. The atomic clock in the satellite is the stratum 0 which is the reference clock for stratum 1 and so on. [^5]</p><h2 id="Clock-bound"><a href="#Clock-bound" class="headerlink" title="Clock bound"></a>Clock bound</h2><p>We know that we can‚Äôt trust our clocks anymore. Big giants like Google and AWS have been thinking about what they can do to improve the situation. As a result, they set up the fancy stratum 0 atomic clocks on satellites connected to their data center regions. Clock skew is inevitable, but with this fancy setup, they are able to achieve clock skews that are within certain bounds.</p><blockquote><p>In Spanner‚Äôs case, Google mentions an upper bound of 7ms‚Ä¶..</p></blockquote><p>This means two machines that are part of the spanner cluster can at-most be of 7ms apart. They cleverly use this property:</p><blockquote><p>So how does Spanner use TrueTime to provide linearizability given that there are still inaccuracies between clocks? It‚Äôs actually surprisingly simple. It waits. Before a node is allowed to report that a transaction has committed, it must wait 7ms. Because all clocks in the system are within 7ms of each other, waiting 7ms means that no subsequent transaction may commit at an earlier timestamp, even if the earlier transaction was committed on a node with a clock which was fast by the maximum 7ms. Pretty clever. [^6] </p></blockquote><p>Some interesting things to explore here would be:</p><ul><li><a href="https://cloud.google.com/spanner/docs/true-time-external-consistency">Google‚Äôs TrueTime</a></li><li><a href="https://aws.amazon.com/about-aws/whats-new/2017/11/introducing-the-amazon-time-sync-service/">Amazon‚Äôs Time Sync Service</a></li><li>AWS‚Äôs <a href="https://github.com/aws/clock-bound">clockbound library</a> can give you a timestamp and the bounds of the timestamp which can be used by your application running on EC2.</li></ul><h2 id="Causal-Ordering"><a href="#Causal-Ordering" class="headerlink" title="Causal Ordering"></a>Causal Ordering</h2><p>All the above were attempts to make the clock to be more ‚Äútrustable‚Äù. There is another extreme where things get even more interesting.</p><p>To get there, the first thing you need to note is: It is ‚Äúcausal ordering‚Äù and not ‚Äúcasual ordering‚Äù.</p><p>Causal means ‚Äúone‚Äù thing in a system <em>caused</em> some other thing in the system. If it was not for the first thing, the things that come after that would have never happened.</p><p>I sent some money to my friend and they received it in their bank account. Sending the money is the event that causes the money to be received in my friend‚Äôs account. It can‚Äôt be the other way around: My friend received some money out of nowhere and then I sent the money which went nowhere but got detected from my account - there is no causal order here.</p><p>If you think deeply, we need a clock in most of the distributed systems because we just like to have causal ordering of events happening in our system. Be it an e-commerce app or a banking app, the order in which events flow is what we are interested in.</p><h2 id="Logical-clocks"><a href="#Logical-clocks" class="headerlink" title="Logical clocks"></a>Logical clocks</h2><p>This is where things get exciting even more! Let us say we ditch our system clock altogether.</p><p>Instead of a system clock both our server(s) and client would have their own clock (typically as a shared library). Instead of observing the real-world time from this custom clock, our application logic could observe a monotonically increasing counter value. This counter value could give a number that the event can record and increment for the next event to use.</p><p>Do you see what we did here? Instead of storing ‚Äúevent A‚Äù that happened at a particular time <code>hh:mm:ss</code>, we record that event A happened as the Nth event in our system. If we sort the numbers stored alongside the event, we get the causal ordering of events. This can help us ensure things like my friend doesn‚Äôt get money out of nowhere.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Clock <span class="keyword">struct</span> &#123;</span><br><span class="line">time <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">mu sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clock)</span> <span class="title">Time</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">c.mu.RLock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line"><span class="keyword">return</span> c.time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clock)</span> <span class="title">Increment</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">c.time++</span><br><span class="line"><span class="keyword">return</span> c.time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Both our server and client would have their own clocks.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">clock *Clock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">clock *Clock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And how do we synchronize the time between them? Simple! We just try to adjust the clock whenever we feel like the clock might be running behind.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clock)</span> <span class="title">Adjust</span><span class="params">(time <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.time &gt; time &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.time = time + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here is a toy example of this. The client talks to the server via an HTTP API and tries to store a key-value pair. It will also send its clock time. But the counter (time) value in the Client‚Äôs clock is running behind the server‚Äôs clock. So, the server can respond back with an error - maybe a 400 Bad request and a response header containing the latest server time. Now the clock can adjust itself to that time and reattempt the API call once more with the new time.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is a super toy version of what could happen in the Client</span></span><br><span class="line"><span class="comment">// I really badly want to get away with code instead of diagrams to explain this</span></span><br><span class="line"><span class="comment">// You will now have to excuse me for using `http.Get` and an unbounded recursive call here.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Store</span><span class="params">(key, value <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">resp, err := c.Get(</span><br><span class="line">fmt.Sprintf(<span class="string">&quot;http://localhost:8080/put?key=%s&amp;value=%s,&amp;time=%d&quot;</span>,</span><br><span class="line">key, value, c.clock.Time(),</span><br><span class="line">))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> serverTime, err := strconv.ParseUint(resp.Header.Get(<span class="string">&quot;CLOCK_TIME&quot;</span>), <span class="number">10</span>, <span class="number">64</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.clock.Adjust(serverTime)</span><br><span class="line"><span class="keyword">return</span> c.Store(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resp.Status, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This <code>type Clock struct</code> that we have here is the logical clock. In fact, this was the first of its kind called the Lamport Clock [^7].</p><p>There are other types of logical clocks that can be seen in the wild like vector clocks, hybrid logical clocks, etc. Something for us to explore!</p><p>[^1]:  <a href="https://youtu.be/IjsJLTriLzs?si=qFhFtB1XfWkx1uBs">Clock Skew and Distributed Systems (Donny Nadolny, PagerDuty)</a><br>[^2]: <a href="https://www.perplexity.ai/search/what-is-the-average-clock-skew-GWjRvNpYSbmRad_YHBswMg#0">What is the average clock skew when using NTP?</a><br>[^3]: <a href="https://en.wikipedia.org/wiki/Quartz_clock">Quartz Clock</a><br>[^4]: <a href="https://en.wikipedia.org/wiki/Atomic_clock">Atomic Clock</a><br>[^5]: <a href="https://www.ntp.org/ntpfaq/NTP-s-algo/#5111-what-is-a-reference-clock">NTP FAQ</a><br>[^6]: <a href="https://www.cockroachlabs.com/blog/living-without-atomic-clocks/">Living without atomic clocks: Where CockroachDB and Spanner diverge</a><br>[^7]: Leslie Lamport. 1978. Time, clocks, and the ordering of events in a distributed system. Commun. ACM 21, 7 (July 1978), 558‚Äì565. <a href="https://doi.org/10.1145/359545.359563">https://doi.org/10.1145/359545.359563</a></p><p>~ ~ ~ ~</p><p>Hope you had a good time learning about time!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This is supposed to be a distributed systems blog post that I &lt;a href=&quot;https://bsky.app/profile/vishnubharathi.codes/post/3lcyrndlxvs2u&quot;&gt;
      
    
    </summary>
    
    
      <category term="distributed systems" scheme="https://vishnubharathi.codes/tags/distributed-systems/"/>
    
  </entry>
  
  <entry>
    <title>Fix up</title>
    <link href="https://vishnubharathi.codes/blog/fix-up/"/>
    <id>https://vishnubharathi.codes/blog/fix-up/</id>
    <published>2024-09-13T20:58:08.000Z</published>
    <updated>2024-12-12T18:27:53.828Z</updated>
    
    <content type="html"><![CDATA[<p>I want you to read this post if you are at the verge of quitting your job.</p><p>You want to quit this job because you are unhappy.</p><p>Unhappy about what? recent changes in your team, a culture shift? or maybe the thought that work is not fun here anymore? or maybe you are worried that you are going to get laid off? or maybe you feel that you are being undervalued? or maybe you feel that you are being underpaid? or maybe some other thing(s).</p><p>That‚Äôs a lot of ‚Äúmaybe‚Äùs. It doesn‚Äôt matter what the reason is, because the thing is, ‚Äúyou are unhappy‚Äù and you must do something about it.</p><p>Ok, so what can you do about it?</p><p>I realized that we have two options here.</p><p>Option one: shut up.</p><p>Option two: fix up.</p><p>Shut up means you literally shut up, grind your nights and weekends, focus on finding a new job, and quit your current job.</p><p>Fix up is a messy route. I have seen the best engineers whom I have worked with to shy away from this path. It takes a certain level of clarity, courage, and bravery to pull it off. (especially if you are living paycheck to paycheck like me - lol)</p><p>Here is how to fix up. You write down all the things that you are unhappy about on a piece of paper. Promise me that you will be brutally honest with yourself while writing this list. And here is the difficult part: You are going to go to your leadership team and share that you are unhappy and read them the list that you prepared. That usually means scheduling a call with your manager, or your manager‚Äôs manager (in case of a larger org), or your CEO (in case of startups). Meet up with the person you are most comfortable with (and that ideally will be your manager and in some unfortunate circumstances not).</p><p>Fix up will not just try to fix the situation for you. It has the potential to fix the situation for your colleagues who are in the same boat as you. It is going to empower your leadership team to do the right things. It can even save the entire company.</p><p>Here is a side note for people who are in leadership roles who are reading this post: The best thing that you can do for your team is to create an environment where one feels to ‚Äúfix up‚Äù without having to get an offer letter from another company. I don‚Äôt know how exactly you are going to do it but I will leave it as an activity for the readers.</p><p>Back to you now. I want you to seriously consider this path because it might be the shortest path to regain your happiness.</p><p>If you are in good hands, your leaders are going to empathize with you and act upon the feedback that you give them or find a way to help you. I will give you an example: I tried to ‚Äúfix up‚Äù before in one of my previous jobs (but with a new job offer though - I was such a coward, lol). I spoke with the CEO and my reason was ‚Äúwork was not fun anymore‚Äù. The CEO acted immediately. He had a bunch of interesting work for which he was not finding time/people to do. He proposed I team up with him and try it out. So for the next few months, I reported to him directly and we tackled the project. That made me regain happiness and at the same time helped the company move on to the next phase.</p><p>I mentioned courage and bravery at the start because you have to try to ‚Äúfix up‚Äù without getting a new job offer. In my above case, I did with an offer and that is a waste of time for you and the people who chose to interview you. Imagine all the time I spent preparing for interviews and all the time and energy of the company (that extended an offer) spent interviewing me. Imagine all the things that I could have done (like watching Cartoon Network or something) instead of preparing all those nights and it is such a waste to decline job offers.</p><p>So, go ahead, be brave, and fix up!</p><p>Best case, you are happy again.</p><p>Worst case, what is going to happen? Your leadership team doesn‚Äôt act up on it. I can hear the paranoid human inside you screaming, ‚ÄúWhat if they blackmark me for saying things aloud? Are they going to fire me because I am not a culture fit anymore?‚Äù. I will run by your script here. Let us hit your deepest fear, ‚ÄúThey are going to fire me‚Äù. Well, what if they do fire you? What are you going to do?</p><p>You are going to prepare full-time for interviews sitting at your comfy little house and appear for interviews and get a new job. And you are happy again.</p><p>The reason why one might not choose to fix up is because they already gave up hope on their leaders or it could be that they don‚Äôt understand the cost of switching jobs. Switching jobs is a costly act, you know! Both for you and the company. Especially in startups where one person gets to work on a lot of diverse stuff. Think about the struggle that your colleagues and your company might go through when you choose to leave them. Kind of sad, right? I am not suggesting that you should not switch jobs at all (lol, look at my LinkedIn) - you should switch if that is what makes you happy again. Remember ‚Äúyour happiness‚Äù is your core metric. When you are happy, you can make wonders happen and do your best work. But I guess your company usually deserves a fix up if you think it is going to help the company (with or without you).</p><p>~ ~ ~ ~</p><p>I would like to thank <a href="https://svs.io">svs</a> for listening to me through a career chat and offering his suggestions. That conversation made me think about and write down this blog post. BTW, if you are looking for a new job, you have to <a href="https://recruit.svs.io/">talk to him</a>.</p><p>And thanks to <code>git rebase -i</code> - that is where I copied the word ‚Äúfix up‚Äù from.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I want you to read this post if you are at the verge of quitting your job.&lt;/p&gt;
&lt;p&gt;You want to quit this job because you are unhappy.&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="career advice" scheme="https://vishnubharathi.codes/tags/career-advice/"/>
    
  </entry>
  
  <entry>
    <title>Know when to break up with Go&#39;s http.DefaultClient</title>
    <link href="https://vishnubharathi.codes/blog/know-when-to-break-up-with-go-http-defaultclient/"/>
    <id>https://vishnubharathi.codes/blog/know-when-to-break-up-with-go-http-defaultclient/</id>
    <published>2024-07-07T15:32:27.000Z</published>
    <updated>2024-12-12T18:27:53.828Z</updated>
    
    <content type="html"><![CDATA[<p>These might be the first set of snippets that you see when trying to use Go‚Äôs HTTP client. (taken from the ‚Äúoverview‚Äù section of <a href="https://pkg.go.dev/net/http">the standard library docs</a>)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">&quot;http://example.com/&quot;</span>)</span><br><span class="line">...</span><br><span class="line">resp, err := http.Post(<span class="string">&quot;http://example.com/upload&quot;</span>, <span class="string">&quot;image/jpeg&quot;</span>, &amp;buf)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>The same set of snippets has the potential to cause your first production outage. It is perfectly good code (up to a certain point). Things will start to get dirty when you introduce the following things into the mix:</p><ul><li>when your program is starting to make a lot of HTTP calls.</li><li>when your program is making HTTP calls to more than one service (host names).</li></ul><p>The reason behind it is this little variable declared in the <code>net/http</code> package.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultClient = &amp;Client&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Meet-the-DefaultClient"><a href="#Meet-the-DefaultClient" class="headerlink" title="Meet the DefaultClient"></a>Meet the DefaultClient</h2><p><code>DefaultClient</code> is of type <code>*http.Client</code> and <code>http.Client</code> is the struct that has all the code to perform HTTP calls. <code>DefaultClient</code> is a HTTP client with all the underlying settings pointing to the default values.</p><p>When you try calling those package-level HTTP methods like <code>http.Get</code>, <code>http.Post</code>, <code>http.Do</code> etc., the HTTP call is made using the <code>DefaultClient</code> variable. Two fields in the <code>http.Client</code> struct could translate the ‚Äúdefault‚Äù and ‚Äúshared‚Äù behavior of <code>http.DefaultClient</code> into potential problems:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Transport specifies the mechanism by which individual</span></span><br><span class="line"><span class="comment">// HTTP requests are made.</span></span><br><span class="line"><span class="comment">// If nil, DefaultTransport is used.</span></span><br><span class="line">Transport RoundTripper</span><br><span class="line"></span><br><span class="line"><span class="comment">// .............</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Timeout specifies a time limit for requests made by this</span></span><br><span class="line"><span class="comment">// Client. The timeout includes connection time, any</span></span><br><span class="line"><span class="comment">// redirects, and reading the response body. The timer remains</span></span><br><span class="line"><span class="comment">// running after Get, Head, Post, or Do return and will</span></span><br><span class="line"><span class="comment">// interrupt reading of the Response.Body.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Timeout of zero means no timeout.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The Client cancels requests to the underlying Transport</span></span><br><span class="line"><span class="comment">// as if the Request&#x27;s Context ended.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">Timeout time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The default value for <code>Timeout</code> is zero, so the <code>http.DefaultClient</code> does not timeout by default and will try to hold on to a local port/socket as long as the connection is live. What if there are too many requests? Combine this with an HTTP server which doesn‚Äôt timeout. Bingo! You got a production outage. You will run out of ports and there won‚Äôt be newer ports available for making further HTTP calls.</p><p>Next up is the <code>Transport</code> field in the <code>http.Client</code>. By default, the following <code>DefaultTransport</code> would be used in <code>DefaultClient</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class="line">Proxy: ProxyFromEnvironment,</span><br><span class="line">DialContext: defaultTransportDialContext(&amp;net.Dialer&#123;</span><br><span class="line">Timeout:   <span class="number">30</span> * time.Second,</span><br><span class="line">KeepAlive: <span class="number">30</span> * time.Second,</span><br><span class="line">&#125;),</span><br><span class="line">ForceAttemptHTTP2:     <span class="literal">true</span>,</span><br><span class="line">MaxIdleConns:          <span class="number">100</span>,</span><br><span class="line">IdleConnTimeout:       <span class="number">90</span> * time.Second,</span><br><span class="line">TLSHandshakeTimeout:   <span class="number">10</span> * time.Second,</span><br><span class="line">ExpectContinueTimeout: <span class="number">1</span> * time.Second,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(a lot of things in there, but turn your attention to <code>MaxIdleConns</code>)</p><p>Here is the doc on what it does:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MaxIdleConns controls the maximum number of idle (keep-alive)</span></span><br><span class="line"><span class="comment">// connections across all hosts. Zero means no limit.</span></span><br><span class="line">MaxIdleConns <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>Since the <code>DefaultClient</code> is shared, you might end up making calls to more than one service (host names) from it. In that case, there might be an unfair distribution of the <code>MaxIdleConns</code> maintained by the default client for the given set of hosts.</p><h2 id="A-small-example"><a href="#A-small-example" class="headerlink" title="A small example"></a>A small example</h2><p>Let us take an example here:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LoanAPIClient <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LoanAPIClient)</span> <span class="title">List</span><span class="params">()</span> <span class="params">([]Loan, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">err := http.Get(<span class="string">&quot;https://loan.api.example.com/v1/loans&quot;</span>)</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PaymentAPIClient <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PaymentAPIClient)</span> <span class="title">Pay</span><span class="params">(amount <span class="keyword">int</span>)</span> <span class="params">(error)</span></span> &#123;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">err := http.Post(<span class="string">&quot;https://payment.api.example.com/v1/card&quot;</span>, <span class="string">&quot;application/json&quot;</span>, &amp;req)</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Both <code>LoanAPIClient</code> and <code>PaymentAPIClient</code> use the <code>http.DefaultClient</code> by calling into <code>http.Get</code> and <code>http.Post</code>. Let us say our program makes 80 calls from <code>LoanAPIClient</code> initially and then makes 200 calls from <code>PaymentAPIClient</code>. By default <code>DefaultClient</code> only maintains 100 maximum idle connections. So, <code>LoadAPIClient</code> will capture 80 spots in those 100 spots, and <code>PaymentAPIClient</code> will only get 20 remanining spots. This means that for the rest of 60 calls from <code>PaymentAPIClient</code>, a new connection needs to be opened and closed. This will cause unnecessary pressure on the payments API server. The allocation of these MaxIdleConns will soon get out of your hands! (trust me üòÖ)</p><h2 id="How-do-we-fix-this"><a href="#How-do-we-fix-this" class="headerlink" title="How do we fix this?"></a>How do we fix this?</h2><p>Increase the <code>MaxIdleConns</code>? Yes, you can but if the client is still shared between <code>LoanAPIClient</code> and <code>PaymentAPIClient</code> then that too shall get out of hand at some scale.</p><p>I discovered the sibling of <code>MaxIdleConns</code> and that is <code>MaxIdleConnsPerHost</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MaxIdleConnsPerHost, if non-zero, controls the maximum idle</span></span><br><span class="line"><span class="comment">// (keep-alive) connections to keep per-host. If zero,</span></span><br><span class="line"><span class="comment">// DefaultMaxIdleConnsPerHost is used.</span></span><br><span class="line">MaxIdleConnsPerHost <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>This could help in maintaining a predictable number of idle connections for each endpoint (host name).</p><h2 id="OK-how-do-I-really-fix-this"><a href="#OK-how-do-I-really-fix-this" class="headerlink" title="OK, how do I really fix this?"></a>OK, how do I really fix this?</h2><p>If your program is calling into more than one HTTP service, then you might most probably want to tweak other settings of the Client too. So, it might be beneficial to have a separate <code>http.Client</code> for these services. That way we can fine-tune them if needed in the future.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LoanAPIClient <span class="keyword">struct</span> &#123;</span><br><span class="line">client *http.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PaymentAPIClient <span class="keyword">struct</span> &#123;</span><br><span class="line">client *http.Client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="It-is-fine"><a href="#It-is-fine" class="headerlink" title="It is fine"></a>It is fine</h2><p>The conclusion would be this: It is okay to use <code>http.DefaultClient</code> to start with. But if you think you will have more clients and will make more API calls, avoid it.</p><p>Bonus: If you are authoring a library that has an API client, do a favor for your users: provide a way to customize the <code>http.Client</code> that you are using to make API calls. That way, your users have full control of what they would like to achieve while using your client.</p><p>~ ~ ~ ~</p><p>HTTP Clients inside an HTTP Server talking to another HTTP Server that has HTTP Clients, all authored by you. That will be your cue.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;These might be the first set of snippets that you see when trying to use Go‚Äôs HTTP client. (taken from the ‚Äúoverview‚Äù section of &lt;a href=
      
    
    </summary>
    
    
      <category term="go" scheme="https://vishnubharathi.codes/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Against the io.TeeReader</title>
    <link href="https://vishnubharathi.codes/blog/against-the-io.teereader/"/>
    <id>https://vishnubharathi.codes/blog/against-the-io.teereader/</id>
    <published>2024-06-28T18:37:19.000Z</published>
    <updated>2024-12-12T18:27:53.824Z</updated>
    
    <content type="html"><![CDATA[<p>This is a follow-up blog post to my previous blog post about the <code>io.TeeReader</code> in Go. Here is the link for it if you haven‚Äôt read it yet: <a href="https://vishnubharathi.codes/blog/a-silly-mistake-that-i-made-with-io.teereader/">https://vishnubharathi.codes/blog/a-silly-mistake-that-i-made-with-io.teereader/</a></p><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>The motivation for this blog post is <a href="https://www.reddit.com/r/golang/comments/1dpfz28/comment/lah1uzz/">this Reddit comment</a>. One of the reasons why I write blog posts and share them on the internet is because I almost always learn more from the comments. That comment made me think more about the code I wrote in the previous blog post and realize some things I want to write up here. (A big thanks to the people writing insightful comments on the internet)</p><h2 id="That-weird-new-bytes-Buffer"><a href="#That-weird-new-bytes-Buffer" class="headerlink" title="That weird new(bytes.Buffer)"></a>That weird <code>new(bytes.Buffer)</code></h2><p>To recap, I had a <code>io.Reader</code> as input and I was trying to read it twice so that I could upload the same data two times. Here is how the final solution looked like when using an <code>io.TeeReader</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">contentForSecondUpload := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">contentForFirstUpload := io.TeeReader(r, contentForSecondUpload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := firstUpload(contentForFirstUpload); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := secondUpload(contentForSecondUpload); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I always felt weird about the <code>new(bytes.Buffer)</code> that I have allocated in the code.</p><h2 id="The-whole-point"><a href="#The-whole-point" class="headerlink" title="The whole point"></a>The whole point</h2><p>The whole point of <code>io.TeeReader</code> is to take in one source reader and perform reads on it efficiently and make the data available at the other two ends of the ‚ÄúT‚Äù.</p><p>One of the highlights of that Reddit comment is, if I am allocating a buffer to store the contents of the source reader, why use a TeeReader at all?</p><blockquote><p>If you‚Äôre going to allocate a buffer, then you might read the entire thing into memory first and read it twice.</p></blockquote><p>That would look like</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">contentForUpload, err := io.ReadAll(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := firstUpload(bytes.NewReader(contentForUpload)); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := secondUpload(bytes.NewReader(contentForUpload)); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This is a valid solution if I am okay with reading the entire input in memory and want my uploads to happen synchronously one after another.</p><h2 id="io-TeeReader-io-Pipe"><a href="#io-TeeReader-io-Pipe" class="headerlink" title="io.TeeReader + io.Pipe"></a>io.TeeReader + io.Pipe</h2><p>The comment made me realize that we could use <code>io.TeeReader</code> and <code>io.Pipe</code> together to achieve concurrent uploads like my final solution in the previous blog post did.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">contentForSecondUpload, contentWriter := io.Pipe()</span><br><span class="line">contentForFirstUpload := io.TeeReader(r, contentWriter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> upload errgroup.Group</span><br><span class="line">upload.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> firstUpload(contentForFirstUpload)</span><br><span class="line">&#125;)</span><br><span class="line">upload.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> secondUpload(contentForSecondUpload)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> upload.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I am going to take this step by step. The above program would cause a deadlock. The reason: <code>contentWriter</code> is not closed and the <code>secondUpload</code> will always be waiting for more content to be available which it will never receive. To fix it, we must close the <code>contentWriter</code> somewhere, but where?</p><p>In the case of the pure <code>io.Pipe</code> implementation in the previous blog post, it was clear: We close the writers in the go routine where we finish the writing.</p><p>In the case of a TeeReader, the writes for <code>contentForSecondUpload</code> is complete when the read of <code>contentForFirstUpload</code> is finished. That looks like:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">contentForSecondUpload, contentWriter := io.Pipe()</span><br><span class="line">contentForFirstUpload := io.TeeReader(r, contentWriter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> upload errgroup.Group</span><br><span class="line">upload.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">contentWriter.CloseWithError(err)</span><br><span class="line">&#125;()</span><br><span class="line">err = firstUpload(contentForFirstUpload)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;)</span><br><span class="line">upload.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> secondUpload(contentForSecondUpload)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> upload.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I feel that the above code would be hard to follow. It can easily make one spend time thinking about ‚Äúwhy would they close the writer of the second reader after reading the first reader?‚Äù.</p><p>The pure <code>io.Pipe</code> implementation feels more natural and human-friendly: we close the writer in the go routine where we are done writing to all the writers. At the same time, it gets the job done.</p><h2 id="Verdict"><a href="#Verdict" class="headerlink" title="Verdict"></a>Verdict</h2><p>I will avoid using <code>io.TeeReader</code> at all places and prefer using <code>io.Pipe + io.MultiWriter</code> instead. (the code from the previous blog post)</p><p>That makes the code efficient, concurrent, and easy to read/write/extend.</p><p>~ ~ ~ ~</p><p>Always use the pipe and close it.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This is a follow-up blog post to my previous blog post about the &lt;code&gt;io.TeeReader&lt;/code&gt; in Go. Here is the link for it if you haven‚Äôt 
      
    
    </summary>
    
    
      <category term="go" scheme="https://vishnubharathi.codes/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>A silly mistake that I made with io.TeeReader</title>
    <link href="https://vishnubharathi.codes/blog/a-silly-mistake-that-i-made-with-io.teereader/"/>
    <id>https://vishnubharathi.codes/blog/a-silly-mistake-that-i-made-with-io.teereader/</id>
    <published>2024-06-27T00:39:47.000Z</published>
    <updated>2024-12-12T18:27:53.824Z</updated>
    
    <content type="html"><![CDATA[<p>I recently made a silly mistake while using <code>io.TeeReader</code> in Go and I am writing this blog post to sum up my learnings from this experience.</p><h2 id="Why-I-used-it-in-the-first-place"><a href="#Why-I-used-it-in-the-first-place" class="headerlink" title="Why I used it in the first place"></a>Why I used it in the first place</h2><p>Ok, here is why I chose to use it in the first place: I had some content and two functions that needed that content and perform uploads to two different HTTP endpoints. Something like</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Upload(strings.NewReader(<span class="string">&quot;hello world&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := firstUpload(r); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := secondUpload(r); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstUpload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">content := io.MultiReader(strings.NewReader(<span class="string">&quot;first upload:&quot;</span>), r, strings.NewReader(<span class="string">&quot;\n&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> _, err := io.Copy(os.Stdout, content); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">secondUpload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">content := io.MultiReader(strings.NewReader(<span class="string">&quot;second upload:&quot;</span>), r, strings.NewReader(<span class="string">&quot;\n&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> _, err := io.Copy(os.Stdout, content); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The output of the above program would be</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first upload:hello world</span><br><span class="line">second upload:</span><br></pre></td></tr></table></figure><p>The first upload consumes all the data from the reader and by the time the reader reaches the second upload, there isn‚Äôt anything to be read. If this is new to you, I encourage you to take a look at the standard lib docs for <code>io.Reader</code> to better understand the situation: <a href="https://pkg.go.dev/io#Reader">https://pkg.go.dev/io#Reader</a></p><h2 id="Using-TeeReader-but-with-my-mistake"><a href="#Using-TeeReader-but-with-my-mistake" class="headerlink" title="Using TeeReader (but with my mistake)"></a>Using TeeReader (but with my mistake)</h2><p>OK, so what do I do now? I google search the problem and discover about Go‚Äôs <a href="https://pkg.go.dev/io#TeeReader">io.TeeReader</a>. Let us see what the program would look like after I tried to use the TeeReader.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">contentForFirstUpload := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">contentForSecondUpload := io.TeeReader(r, contentForFirstUpload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := firstUpload(contentForFirstUpload); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := secondUpload(contentForSecondUpload); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And the output for this is</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first upload:</span><br><span class="line">second upload:hello world</span><br></pre></td></tr></table></figure><p>That is weird. The second upload is succeeding but not the first one?</p><h2 id="Fixing-the-mistake"><a href="#Fixing-the-mistake" class="headerlink" title="Fixing the mistake"></a>Fixing the mistake</h2><p>This probably is the best place to quote the docs of <code>io.TeeReader</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TeeReader</span><span class="params">(r Reader, w Writer)</span> <span class="title">Reader</span></span></span><br></pre></td></tr></table></figure><blockquote><p>TeeReader returns a Reader that writes to w what it reads from r. All reads from r performed through it are matched with corresponding writes to w. There is no internal buffering - the write must complete before the read completes. Any error encountered while writing is reported as a read error.</p></blockquote><p>So we get back a Reader (<code>contentForSecondUpload</code> in our case) and when that is read, a simultaneous write is happening to the writer (<code>contentForFirstUpload</code> in our case) that we pass. But what happens in the code is, we try to read from the writer before writes are happening to it.</p><p>I am not sure if I did a good job of explaining the fix in plain words above, but here is the code that fixes the problem:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">contentForSecondUpload := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">contentForFirstUpload := io.TeeReader(r, contentForSecondUpload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := firstUpload(contentForFirstUpload); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := secondUpload(contentForSecondUpload); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So rule no.1 here is: always read the reader returned back from <code>io.TeeReader</code> first. That is the thing that is copying the data and making it available for the other buffer (writer).</p><p>That‚Äôs it, that is the only rule.</p><h2 id="io-Pipe"><a href="#io-Pipe" class="headerlink" title="io.Pipe"></a>io.Pipe</h2><p>Now that we have fixed the problem, I think we can take a short detour to visit one of my favorite Go constructs: <code>io.Pipe</code> which could also help solve these kinds of problems.</p><p>Here is a quick refactor of our code using <code>io.Pipe</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upload</span><span class="params">(r io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> upload errgroup.Group</span><br><span class="line"></span><br><span class="line">fr, fw := io.Pipe()</span><br><span class="line">upload.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> firstUpload(fr)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">sr, sw := io.Pipe()</span><br><span class="line">upload.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> secondUpload(sr)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">upload.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fw.CloseWithError(err)</span><br><span class="line">sw.CloseWithError(err)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">_, err = io.Copy(io.MultiWriter(fw, sw), r)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> upload.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This has some advantages and one of them would have helped me in avoiding my mistake with <code>io.TeeReader</code>.</p><ul><li>uploads become concurrent naturally unlike TeeReader where it is sequential.</li><li>the order in which we read the readers for the first upload and second upload does not matter anymore.</li></ul><p>With that said, I would still be mindful about introducing <code>io.Pipe</code>. Here is what I have decided.</p><p>If I need to write to one or two writers and do not need concurrency, I would stick with <code>io.TeeReader</code>. I will stick to <code>io.Pipe</code> for every other case.</p><p>I have changed my mind a bit, please turn to the next page: <a href="https://vishnubharathi.codes/blog/against-the-io.teereader/">https://vishnubharathi.codes/blog/against-the-io.teereader/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I recently made a silly mistake while using &lt;code&gt;io.TeeReader&lt;/code&gt; in Go and I am writing this blog post to sum up my learnings from t
      
    
    </summary>
    
    
      <category term="go" scheme="https://vishnubharathi.codes/tags/go/"/>
    
  </entry>
  
</feed>
